package org.tygus.suslik.synthesis

import org.scalatest.{FunSpec, Matchers}
import org.tygus.suslik.language.Expressions.{IntConst, Subst, Var}
import org.tygus.suslik.language.LocType
import org.tygus.suslik.language.Statements._
import org.tygus.suslik.logic
import org.tygus.suslik.logic.{Block, PFormula, PointsTo, SFormula}
import org.tygus.suslik.logic.Specifications.Assertion
import org.tygus.suslik.synthesis.Evaluator._

import scala.collection.immutable.TreeSet

class EvaluatorTests extends FunSpec with Matchers with SynthesisRunnerUtil {

  override def doRun(testName: String, desc: String, in: String, out: String, params: SynConfig = defaultConfig): Unit = {
    super.doRun(testName, desc, in, out, params)
    it(desc) {
      synthesizeFromSpec(testName, in, out, params)
    }
  }

  describe("evaluator for functions generated by suslik") {
    it("evaluates Load correctly") {
      val s: Statement = Load(Var("v"), LocType, Var("x"))
      val store: Subst = Map(Var("v") -> IntConst(567), Var("x") -> IntConst(123))
      val pre: Heap = Map(123->IntConst(456), 567->IntConst(789))
      val post: Heap = Map(123->IntConst(456), 567->IntConst(456))
      assert(evaluate(s,pre,store)._1 == post )
    }
    it("evaluates Free correctly") {
      val s: Statement = Free(Var("v"))
      val store: Subst = Map(Var("v") -> IntConst(567), Var("x") -> IntConst(123))
      val pre: Heap = Map(123->IntConst(456), 567->IntConst(789))
      val post: Heap = Map(123->IntConst(456))
      assert(evaluate(s,pre,store)._1 == post)
    }
    it("evaluates Malloc correctly for blocks"){
      val s: Statement = Malloc(Var("a"),LocType, 3)
      val store: Subst = Map(Var("v") -> IntConst(567), Var("x") -> IntConst(123), Var("a") -> IntConst(1))
      val pre: Heap = Map(123->IntConst(456), 567->IntConst(789))
      val post: Heap = Map(123->IntConst(456),567->IntConst(789), 1->IntConst(0), 2->IntConst(0), 3-> IntConst(0))
      print(evaluate(s,pre,store))
      assert(evaluate(s,pre,store)._1==post)
    }
    it("evaluates Error correctly"){
      val s: Statement = SeqComp(Malloc(Var("a"),LocType, 3), Error)
      val store: Subst = Map(Var("v") -> IntConst(567), Var("x") -> IntConst(123), Var("a") -> IntConst(1))
      val pre: Heap = Map(123->IntConst(456), 567->IntConst(789))
      val post: Heap = Map.empty
      assert(evaluate(s,pre,store)._1==post)
    }
    }
//    it("evaluates Load correctly in the 'to' parameter") {
//      //let v = *x where *x = "new"
//      //expected result: all instances of v become "new"
//      val s: Statement = Load(Var("v"), LocType, Var("x"))
//      val pre: Heap = List(PointsTo(Var("x"), 0, Var("new")), PointsTo(Var("v"), 0, Var("somethingOtherThan(x)")))
//      val post: Heap = List(PointsTo(Var("x"), 0, Var("new")), PointsTo(Var("new"), 0, Var("somethingOtherThan(x)")))
//      assert(evaluate(s, pre) == post)
//    }
//    it("evaluates Load correctly in the 'from' parameter") {
//      //let v = *x where *x = "new"
//      //expected result: all instances of v become "new"
//      val s: Statement = Load(Var("v"), LocType, Var("x"))
//      val pre: Heap = List(PointsTo(Var("x"), 0, Var("new")), PointsTo(Var("somethingOtherThan(x)"), 0, Var("v")))
//      val post: Heap = List(PointsTo(Var("x"), 0, Var("new")), PointsTo(Var("somethingOtherThan(x)"), 0, Var("new")))
//      assert(evaluate(s, pre) == post)
//    }
//    it("evaluates Free correctly"){
//      val s : Statement = Free(Var("y"))
//      val pre: Heap = List(PointsTo(Var("x"),0,(Var("y"))), PointsTo(Var("y"),0,IntConst(42)),
//                PointsTo(Var("y"),1,IntConst(43)), PointsTo(Var("y"),2,IntConst(44)), Block(Var("y"),3))
//      val post: Heap = List(PointsTo(Var("x"),0,Var("y")))
//      assert(evaluate(s,pre) == post)
//    }
//    it("evaluates Store correctly"){
//      val s : Statement = SeqComp(Store(Var("x"),0,IntConst(43)), Store(Var("y"),1,IntConst(239)))
//      val pre : Heap = List(PointsTo(Var("x"),0,IntConst(1)),PointsTo(Var("y"),1,IntConst(2)),Block(Var("asdf"),3))
//      val post : Heap = List(PointsTo(Var("x"),0,IntConst(43)),PointsTo(Var("y"),1,IntConst(239)),Block(Var("asdf"),3))
//      assert(evaluate(s,pre)==post)
//    }
//    it("evaluates Malloc correctly for blocks"){
//      val s: Statement =SeqComp(Malloc(Var("y"),LocType,3),SeqComp(Store(Var("x"),0,Var("y")),SeqComp(Store(Var("y"),0,IntConst(1)),
//        SeqComp(Store(Var("y"),1,IntConst(2)),SeqComp(Store(Var("y"),2,Var("x")),Skip)))))
//      val pre : Heap = List(PointsTo(Var("x"),0,IntConst(0)))
//      val post: Heap = List(PointsTo(Var("x"),0,Var("y")),
//        Block(Var("y"),3), PointsTo(Var("y"),0,IntConst(1)), PointsTo(Var("y"),1,IntConst(2)), PointsTo(Var("y"),2,Var("x")))
//      // assert equivalence up to formula re-arrangement by abusing property of set.
//      assert(evaluate(s,pre).toSet == post.toSet)
//    }
//  }

}
